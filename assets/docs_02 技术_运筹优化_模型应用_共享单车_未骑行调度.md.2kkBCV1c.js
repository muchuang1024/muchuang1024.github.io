import{_ as e,c as i,o as a,a4 as r}from"./chunks/framework.4aTu-Nia.js";const k=JSON.parse('{"title":"一、问题定义","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型应用/共享单车/未骑行调度.md","filePath":"docs/02 技术/运筹优化/模型应用/共享单车/未骑行调度.md"}'),o={name:"docs/02 技术/运筹优化/模型应用/共享单车/未骑行调度.md"},t=r('<h1 id="一、问题定义" tabindex="-1">一、问题定义 <a class="header-anchor" href="#一、问题定义" aria-label="Permalink to &quot;一、问题定义&quot;">​</a></h1><p>未骑行车辆的闲置时长与车辆的机会收入直接相关，未骑行时长越长车辆损失越大，且长时间未骑行还会提升车辆丢失风险，<strong>本期需求在「降低短中长期未骑行车辆占比」的业务背景下</strong>，通过建设系统生派单能力，对未骑行车辆在空间上进行聚类后派发至未骑行排班运力，将未骑行车辆与司机进行一对一匹配，提升未骑行车辆的找寻难度和找寻成本。</p><p>目标：28天未骑行占可用车比从 0.95% 降低到 0.20% 生单粒度：189 围栏 生单频次：1天1次 每次算法最大用时：8 min</p><h1 id="二、问题建模" tabindex="-1">二、问题建模 <a class="header-anchor" href="#二、问题建模" aria-label="Permalink to &quot;二、问题建模&quot;">​</a></h1><h2 id="_1、集合与参数" tabindex="-1">1、集合与参数 <a class="header-anchor" href="#_1、集合与参数" aria-label="Permalink to &quot;1、集合与参数&quot;">​</a></h2><ul><li><code>K</code>: 司机集合</li><li><code>N</code>: 车辆集合</li></ul><h2 id="_2、决策变量" tabindex="-1">2、决策变量 <a class="header-anchor" href="#_2、决策变量" aria-label="Permalink to &quot;2、决策变量&quot;">​</a></h2><ul><li>$x_{ijk}$:  司机 <code>k</code> 是否从 <code>i</code> 前往 <code>j</code></li><li>$y_{i}$:  司机是否访问车辆 i</li></ul><h2 id="_3-目标函数" tabindex="-1">3. 目标函数 <a class="header-anchor" href="#_3-目标函数" aria-label="Permalink to &quot;3. 目标函数&quot;">​</a></h2><p>最小化总距离：</p><p>$$ min \\sum_{i, j , k} d_{i,j} * x_{i,j,k} $$</p><h2 id="_4-约束条件" tabindex="-1">4. 约束条件 <a class="header-anchor" href="#_4-约束条件" aria-label="Permalink to &quot;4. 约束条件&quot;">​</a></h2><p>车辆数上限 $$ \\sum_i^N y(k, i) \\le maxBikeNum，k \\in V $$</p><p>车辆数下限 $$ \\sum_i^N y(k, i) \\ge minBikeNum，k \\in V $$</p><p>派单均衡</p><p>$$ \\sum_i ^ N y(driver_{k1}, i) - \\sum_i^N y(driver_{k2}, i) &lt;= maxGAP,\\quad k1, k2 \\in K $$ $$ \\sum_i ^ N y(driver_{k1}, i) - \\sum_i^N y(driver_{k2}, i) &gt;= -maxGAP,\\quad k1, k2 \\in K $$</p><h1 id="三、算法求解" tabindex="-1">三、算法求解 <a class="header-anchor" href="#三、算法求解" aria-label="Permalink to &quot;三、算法求解&quot;">​</a></h1><p>分场景建模求解</p><h3 id="场景1-司机多于车" tabindex="-1"><strong>场景1：司机多于车</strong> <a class="header-anchor" href="#场景1-司机多于车" aria-label="Permalink to &quot;**场景1：司机多于车**&quot;">​</a></h3><p><strong>条件</strong>：<code>bikeCnt &lt; driverCnt * minEbikeNum</code></p><ul><li><strong>问题</strong>：车辆数不足以保证每个司机都能分配到最小值要求的车辆</li><li><strong>处理</strong>：减少司机数量，只保留 <code>ceil(bikeCnt / maxEbikeNum)</code> 个司机</li><li><strong>枚举类型</strong>：<code>Driver_DriverMoreThanBike</code></li></ul><h3 id="场景2-车司机平衡" tabindex="-1"><strong>场景2：车司机平衡</strong> <a class="header-anchor" href="#场景2-车司机平衡" aria-label="Permalink to &quot;**场景2：车司机平衡**&quot;">​</a></h3><p><strong>条件</strong>：<code>driverCnt * minEbikeNum ≤ bikeCnt ≤ driverCnt * maxEbikeNum</code></p><ul><li><strong>问题</strong>：车辆数和司机运力基本匹配</li><li><strong>处理</strong>：正常使用所有司机，采用平衡分配策略</li><li><strong>枚举类型</strong>：<code>Driver_DriverBikeBalance</code></li><li><strong>约束</strong>：<code>minBikeNumVar + bikeBalance ≥ maxBikeNumVar</code></li></ul><h3 id="场景3-车多于司机" tabindex="-1"><strong>场景3：车多于司机</strong> <a class="header-anchor" href="#场景3-车多于司机" aria-label="Permalink to &quot;**场景3：车多于司机**&quot;">​</a></h3><p><strong>条件</strong>：<code>bikeCnt &gt; driverCnt * maxEbikeNum</code></p><ul><li><strong>问题</strong>：车辆数超过所有司机的最大运力</li><li><strong>处理</strong>： <ol><li>先用真实司机处理 <code>driverCnt * maxEbikeNum</code> 辆车</li><li>剩余车辆由虚拟司机处理</li><li>虚拟司机数 = <code>ceil(bikeCnt / maxEbikeNum) - driverCnt</code></li></ol></li><li><strong>枚举类型</strong>：<code>Driver_DriverLessThanBike</code></li></ul><h3 id="边界情况处理" tabindex="-1"><strong>边界情况处理</strong> <a class="header-anchor" href="#边界情况处理" aria-label="Permalink to &quot;**边界情况处理**&quot;">​</a></h3><ul><li><strong>车辆太少</strong>：<code>bikeCnt &lt; minEbikeNum</code> → 只用1个司机</li><li><strong>无司机</strong>：<code>driverCnt = 0</code> → 全部用虚拟司机</li></ul>',29),n=[t];function l(d,s,c,h,u,_){return a(),i("div",null,n)}const g=e(o,[["render",l]]);export{k as __pageData,g as default};
