import{_ as o,c as i,o as e,a4 as _,m as t,a as $}from"./chunks/framework.4aTu-Nia.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型建模/建模技巧/子路径消除 MTZ 约束.md","filePath":"docs/02 技术/运筹优化/模型建模/建模技巧/子路径消除 MTZ 约束.md"}'),n={name:"docs/02 技术/运筹优化/模型建模/建模技巧/子路径消除 MTZ 约束.md"},s=_('<p><strong>MTZ 约束</strong> 是用于解决 <strong>TSP (旅行商问题)</strong> 和 <strong>CVRP (带容量的车辆路径问题)</strong> 等整数规划模型中<strong>子路径消除</strong>（Subtour Elimination）的经典方法之一。它引入了一组<strong>连续变量</strong>来代表车辆在访问特定客户时的“状态”（通常是序列位置或剩余载荷）</p><h3 id="_1-车辆路径问题-vrp-基础模型" tabindex="-1">1. 车辆路径问题（VRP）基础模型 <a class="header-anchor" href="#_1-车辆路径问题-vrp-基础模型" aria-label="Permalink to &quot;1. 车辆路径问题（VRP）基础模型&quot;">​</a></h3><p>在解释 MTZ 约束之前，我们先定义基础的 VRP/TSP 模型中的变量：</p><ul><li><p><strong>节点集合 ($N$)：</strong> $N = {0, 1, 2, \\dots, n}$，其中 $0$ 是起点/终点仓库（Depot），$1$ 到 $n$ 是客户点。</p></li><li><p><strong>二元变量 ($x_{ij}$ / $x_{ij}^k$)：</strong> 如果车辆从节点 $i$ 行驶到节点 $j$，则 $x_{ij}=1$ (TSP) 或 $x_{ij}^k=1$ (VRP)，否则为 $0$。</p></li></ul><h3 id="_2-mtz-约束的经典形式-tsp-子路径消除" tabindex="-1">2. MTZ 约束的经典形式（TSP 子路径消除） <a class="header-anchor" href="#_2-mtz-约束的经典形式-tsp-子路径消除" aria-label="Permalink to &quot;2. MTZ 约束的经典形式（TSP 子路径消除）&quot;">​</a></h3><p>经典的 MTZ 公式用于 <strong>消除不包含仓库节点 0 的子路径</strong>，确保所有客户被连接到一个从 0 出发并回到 0 的单一回路中。</p><h4 id="完整的-mtz-公式-tsp" tabindex="-1">完整的 MTZ 公式 (TSP) <a class="header-anchor" href="#完整的-mtz-公式-tsp" aria-label="Permalink to &quot;完整的 MTZ 公式 (TSP)&quot;">​</a></h4>',7),r=t("p",null,[$("$$\\mathbf{u}_i - \\mathbf{u}"),t("em",{ij:""},"j + n \\cdot x"),$(" \\leq n - 1 \\quad \\forall i, j \\in N \\setminus {0}, i \\neq j$$")],-1),a=_('<p>其中：</p><ul><li><p><strong>$u_i$ (连续变量)：</strong> 代表客户 $i$ 在最优路径中的<strong>序列位置</strong>或<strong>访问顺序编号</strong>。</p></li><li><p><strong>$n$：</strong> 客户点的总数量（不包括仓库 0）。</p></li><li><p><strong>$x_{ij}$：</strong> 如果路径包含边 $(i, j)$ 则为 1。</p></li></ul><h4 id="🔍-讲解-mtz-约束的原理" tabindex="-1">🔍 讲解 MTZ 约束的原理 <a class="header-anchor" href="#🔍-讲解-mtz-约束的原理" aria-label="Permalink to &quot;🔍 讲解 MTZ 约束的原理&quot;">​</a></h4><p>该约束的核心思想是利用 $u_i$ 变量来<strong>强制执行顺序</strong>：</p><ol><li><p>如果 $x_{ij}=1$ (边 $(i, j)$ 被选中)：</p><p>约束变为：$u_i - u_j + n \\leq n - 1$，即 $u_i - u_j \\leq -1$，或 $\\mathbf{u}_i + 1 \\leq \\mathbf{u}_j$。</p><p>这强制要求客户 $j$ 的序列位置 ($u_j$) 必须严格大于客户 $i$ 的序列位置 ($u_i$)。这有效地模拟了 $i$ 在 $j$ 之前被访问的顺序关系。</p></li><li><p>如果 $x_{ij}=0$ (边 $(i, j)$ 未被选中)：</p><p>约束变为：$u_i - u_j + 0 \\leq n - 1$，即 $u_i - u_j \\leq n - 1$。</p><p>由于 $u_i$ 的取值范围通常被限制在 $1$ 到 $n$ 之间，这个约束自动满足（最大可能值为 $n - 1$），对 $u_i$ 和 $u_j$ 的顺序没有限制。</p></li></ol><p><strong>如何消除子路径？</strong></p><p>假设存在一个不包含仓库 $0$ 的子路径，例如 $1 \\to 2 \\to 3 \\to 1$。</p><p>根据 MTZ 约束：</p><ul><li><p>$x_{12}=1 \\implies u_1 + 1 \\leq u_2$</p></li><li><p>$x_{23}=1 \\implies u_2 + 1 \\leq u_3$</p></li><li><p>$x_{31}=1 \\implies u_3 + 1 \\leq u_1$</p></li></ul><p>将这三个不等式相加：</p><p>$(u_1 + 1) + (u_2 + 1) + (u_3 + 1) \\leq u_2 + u_3 + u_1$</p><p>$u_1 + u_2 + u_3 + 3 \\leq u_1 + u_2 + u_3$</p><p>$3 \\leq 0$</p><p>这导致一个<strong>矛盾</strong>。因此，任何不包含仓库 $0$ 的循环（子路径）都<strong>不能</strong>满足 MTZ 约束，从而在模型的解中被消除。</p>',14),p=[s,r,a];function l(u,c,d,g,T,h){return e(),i("div",null,p)}const q=o(n,[["render",l]]);export{j as __pageData,q as default};
