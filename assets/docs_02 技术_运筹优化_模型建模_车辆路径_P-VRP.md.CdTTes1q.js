import{_ as t,c as o,o as r,a4 as s}from"./chunks/framework.4aTu-Nia.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型建模/车辆路径/P-VRP.md","filePath":"docs/02 技术/运筹优化/模型建模/车辆路径/P-VRP.md"}'),n={name:"docs/02 技术/运筹优化/模型建模/车辆路径/P-VRP.md"},a=s('<h2 id="一、背景" tabindex="-1">一、背景 <a class="header-anchor" href="#一、背景" aria-label="Permalink to &quot;一、背景&quot;">​</a></h2><p>当<strong>所有客户的总需求</strong>超过了<strong>所有可用车辆的最大载重总和</strong>时，即使每辆车都满载，也无法运送完所有货物。此时，模型无法找到一个满足“所有客户都必须访问”的路径集合，因此数学模型无法找到可行解</p><p>资源不足导致所有硬约束无法满足时，问题是<strong>无解的</strong>。但在实际应用中，我们可以<strong>引入惩罚变量</strong>或<strong>允许资源弹性</strong>（如多程、租用车辆）将无解问题转化为一个有<strong>实用解</strong>的优化问题。</p><p>本文主要介绍通过带惩罚的 VRP (Penalty VRP, P-VRP)，实现将无解问题转化为一个有<strong>实用解</strong>的优化问题</p><h2 id="二、实现方式" tabindex="-1">二、实现方式 <a class="header-anchor" href="#二、实现方式" aria-label="Permalink to &quot;二、实现方式&quot;">​</a></h2><p>引入一个新的<strong>二元变量 $z_i$</strong>，表示客户 $i$ 是否被访问。如果 $z_i=0$（未被访问），则在目标函数中加上一个<strong>巨大的惩罚项 $M \\cdot z_i$</strong></p><p>求解器会权衡，如果必须放弃某些客户才能满足全覆盖约束，它会选择放弃那些惩罚最小（重要性最低）的客户，从而找到一个<strong>最优的可行子集</strong></p><p><strong>全覆盖约束：</strong> <strong>所有</strong>客户点 $i \\in {1, \\dots, n}$ 必须被且仅被<strong>访问一次</strong>。这是 VRP 最基本的定义之一。</p>',8),e=[a];function _(c,g,i,d,p,P){return r(),o("div",null,e)}const $=t(n,[["render",_]]);export{h as __pageData,$ as default};
