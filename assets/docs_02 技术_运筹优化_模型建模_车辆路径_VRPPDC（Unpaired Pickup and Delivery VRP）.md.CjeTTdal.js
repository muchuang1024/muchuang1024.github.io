import{_ as n,c as s,o as t,a4 as p}from"./chunks/framework.4aTu-Nia.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型建模/车辆路径/VRPPDC（Unpaired Pickup and Delivery VRP）.md","filePath":"docs/02 技术/运筹优化/模型建模/车辆路径/VRPPDC（Unpaired Pickup and Delivery VRP）.md"}'),o={name:"docs/02 技术/运筹优化/模型建模/车辆路径/VRPPDC（Unpaired Pickup and Delivery VRP）.md"},a=p(`<p>未配对取送货</p><p>如果取点和送点未知，只知道哪些点是取点，哪些点是送点，能给出实现代码吗？</p><p>这是 VRPPD（带取送货的车辆路径问题）的一个更复杂的变体，被称为 <strong>VRPPDC (Vehicle Routing Problem with Pick-up and Delivery Constraints)</strong> 或 <strong>Unpaired P&amp;D</strong>。</p><p>在这种情况下，我们不再有确定的 (Pi​,Di​) 配对关系，只知道：</p><ol><li><p><strong>集合 P：</strong> 所有的取货点 (Pick-up nodes)。</p></li><li><p><strong>集合 D：</strong> 所有的送货点 (Delivery nodes)。</p></li><li><p><strong>约束：</strong> 必须满足<strong>总容量约束</strong>和<strong>货物守恒约束</strong>（即所有取货需求的总和必须等于所有送货需求的总和）</p></li></ol><p>OR-Tools 的 Routing Library <strong>不能直接</strong>处理这种未配对的情况，因为它依赖于明确的 <code>pickups_deliveries</code> 映射关系来建立<strong>成对约束</strong>。要解决这个问题，我们必须回到 <strong>整数规划 (IP)</strong> 的思路上，使用 <strong>流变量 (Flow Variables)</strong> 来追踪货物从哪个取货点流向哪个送货点。</p><p>由于这需要构建一个完整的 IP 模型（比 MTZ 模型复杂得多），通常会使用 OR-Tools 的<strong>底层 CP-SAT 求解器</strong>或 <strong>线性规划</strong> API 来实现，而不是 Routing Library。</p><p>核心拓展：</p><p>你 <strong>不事先知道 pickup 和 delivery 的配对关系</strong> ，求解器需要同时做两件事：</p><ol><li><p><strong>决定哪些取点对应哪些送点（匹配阶段）</strong></p></li><li><p><strong>决定车辆路径（调度阶段）</strong></p></li></ol><ul><li><p><strong>载重流：</strong> 载重是<strong>双向变化</strong>的。卡车在取货点增加载荷，在送货点减少载荷。</p></li><li><p><strong>核心约束：</strong></p><ol><li><p><strong>最大容量：</strong> $L \\le Q$（物理超载）。</p></li><li><p><strong>非负载重：</strong> $L \\ge 0$（逻辑约束：防止先送后取）</p></li></ol></li></ul><p>VRPPDC 必须引入额外的 <strong>非负载重约束</strong> ($L \\ge 0$) 来解决其特有的逻辑问题，这在 CVRP 中是不存在的。</p><p>这个 $L \\ge 0$ 约束的数学实现，强制了<strong>取货的发生时间必须在送货之前</strong>。这个约束极大地收紧了可行的路线空间，增加了求解器寻找有效路径的难度。</p><p>在 OR-Tools 中实现这种<strong>双向载重流</strong>和<strong>非负约束</strong>，需要使用更高级的维度设置和软惩罚机制（如你代码中的 <code>SetCumulVarSoftLowerBound</code>），或者使用复杂的 IP/CP-SAT 模型，这都比简单的 CVRP 成本设置要复杂得多。</p><p>如果求解器找到一条路径，例如 $0 \\to D1$ (送货点)，由于 $D1$ 的需求是 $-10$，那么 $L_{D1} = 0 + (-10) = -10$。</p><p>此时：</p><ul><li><p>$L_i = -10$</p></li><li><p>$L_{\\min} = 0$</p></li><li><p>$\\text{Violation}_{D1} = 0 - (-10) = 10$</p></li></ul><p>求解器会将 $\\text{Objective} + 100,000 \\times 10$ (即 <strong>1,000,000</strong>) 添加到总成本中。</p><p>由于 $P$ 设置得非常大，模型会<strong>极力避免</strong>任何 $L_i &lt; 0$ 的路径，从而保证了 <strong>“取货必须在送货之前”</strong> 的逻辑。</p><p>$$\\text{Objective}<em>{\\text{new}} = \\text{Objective}</em>{\\text{original}} + \\sum_{i \\in \\text{Nodes}} \\left( P \\times \\text{Violation}_i \\right)$$</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 如果 L &lt; 0，对 L 的最小值施加惩罚</span></span>
<span class="line"><span></span></span>
<span class="line"><span>load_dimension.SetCumulVarSoftLowerBound(</span></span>
<span class="line"><span></span></span>
<span class="line"><span>index,</span></span>
<span class="line"><span></span></span>
<span class="line"><span>data[&quot;max_negative_load&quot;], # 强制 L &gt;= 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>data[&quot;load_penalty&quot;], # 违反约束时的巨大惩罚</span></span>
<span class="line"><span></span></span>
<span class="line"><span>)</span></span></code></pre></div>`,21),e=[a];function i(r,l,g,c,d,_){return t(),s("div",null,e)}const $=n(o,[["render",i]]);export{u as __pageData,$ as default};
