import{_ as t,c as o,o as s,a4 as e}from"./chunks/framework.4aTu-Nia.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/运筹优化/优化技巧.md","filePath":"docs/02 技术/运筹优化/运筹优化/优化技巧.md"}'),_={name:"docs/02 技术/运筹优化/运筹优化/优化技巧.md"},r=e("<p>1、合并重复区间 2、抽样选点，设置步长 3、添加对称性打破约束（如对街道按收益排序后强制<code>x_i &gt;= x_j</code>），减少无效搜索空间。 4、高效初始解，对比添加初始解 vs 不添加初始解的效果 5、<strong>模型本身的优化</strong>：比如是否有更高效的约束表达方式，或者是否存在冗余的约束可以去除，从而减少求解器的计算量。例如，预测订单数矩阵的处理方式是否可以被简化，或者是否存在某些街道之间的依赖关系可以被更高效地建模。 6、<strong>求解参数调整</strong>：CP-SAT求解器有很多参数可以调整，比如搜索策略、并行线程数、随机种子等。调整这些参数可能减少冲突数和分支次数，从而加快求解速度。例如，使用不同的搜索策略可能更适合这个问题结构，或者增加并行计算资源。 7、 <strong>预测订单模型的简化</strong>：如果预测订单的矩阵非常复杂，可能需要更高效的数据结构或者近似方法。例如，是否可以使用分段连续函数近似代替离散的预测矩阵。 8、<strong>问题分解或启发式方法</strong>：对于大规模问题，可以考虑将问题分解为子问题，或者使用启发式方法先得到一个较好的初始解，再用精确方法优化。例如对某些街道进行聚类，多个子问题分别求解，减少每次求解的变量数量。 9、<strong>数据预处理</strong>：检查输入的预测数据是否存在噪声或冗余，或者是否存在某些街道的投放量对订单数影响较小，从而可以固定这些街道的投放量，减少变量数目。 10、<strong>硬件资源</strong>：增加计算资源，如使用更强大的CPU或者分布式计算，虽然这可能不是算法层面的优化，但有时实际应用中可以考虑。 11、约束条件优化：街道上下限优化 12、线性优化：根据抽样预测矩阵进行分段线性拟合 13、根据城市 OP 分簇（可控） 14、松弛求近似解</p>",1),n=[r];function a(c,d,g,i,p,l){return s(),o("div",null,n)}const P=t(_,[["render",a]]);export{f as __pageData,P as default};
