import{_ as a,c as e,o as n,a4 as t}from"./chunks/framework.4aTu-Nia.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/调度算法.md","filePath":"docs/02 技术/运筹优化/调度算法.md"}'),s={name:"docs/02 技术/运筹优化/调度算法.md"},i=t(`<p>#运筹优化</p><p>在前置仓配送系统中，一个核心问题是如何高效地将订单分配给骑手，以确保订单及时准确地送达顾客手中。这个问题涉及到多个因素，包括订单的紧急程度、骑手的位置和状态、配送路线的选择等。合理的订单分配策略可以提高配送效率，减少成本，提高顾客满意度。</p><h2 id="一、问题定义" tabindex="-1">一、问题定义 <a class="header-anchor" href="#一、问题定义" aria-label="Permalink to &quot;一、问题定义&quot;">​</a></h2><p>已知 N 个订单，M 个骑手，如何分配才能使得整体的配送效率更高、用户体验更好、骑手体验更好？</p><h2 id="二、问题建模" tabindex="-1">二、问题建模 <a class="header-anchor" href="#二、问题建模" aria-label="Permalink to &quot;二、问题建模&quot;">​</a></h2><h3 id="一-决策变量" tabindex="-1">一）决策变量 <a class="header-anchor" href="#一-决策变量" aria-label="Permalink to &quot;一）决策变量&quot;">​</a></h3><p>$x_{i j}$ : 如果订单 <code>i</code> 被分配给骑手 <code>j</code>，则 $x_{i j}$ = 1，否则 $x_{i j}$ = 0</p><p>$z_{i j}$ : 骑手 k 从订单 <code>i</code> 到 <code>j</code>，则 $z_{i j}$ = 1，否则 $z_{i j}$ = 0</p><p>骑手出发时间（由身上的订单确定）</p><h3 id="二-目标函数" tabindex="-1">二）目标函数 <a class="header-anchor" href="#二-目标函数" aria-label="Permalink to &quot;二）目标函数&quot;">​</a></h3><p>怎么选择最优解？基于补偿，之前准时率比较低，优先剩余时间；之前骑手</p><p><strong>既关注整体也关注个体的目标函数</strong>，统一量纲，然后根据业务的重要性计算权重，自适应调整权重</p><p>订单与骑手的匹配方案中，如果交换 2 个骑手身上的订单（2个骑手订单数相同），<strong>整体可能指标都是一样的</strong>，优先选择优先级惩罚低的分配方案</p><p><strong>按订单类型优先分配</strong>：</p><p><strong>紧急订单优先</strong>：优先分配紧急订单，如预约结束时间-预计送达 &lt; 30min 的订单。 <strong>高价值订单优先</strong>：优先分配高价值或重要客户的订单，以提高客户满意度。</p><p>如果分配数量是一定的情况下，不存在先分派订单多还是订单少，因为分配的都是一样的</p><p>对于相同骑手数：需要控制的是先分派紧急的，还是高价值的 对于不同骑手数：需要控制单均往返距离</p><p>超时时长最大的问题：太滞后，并且权重相同，如果2个骑手订单一样，无论怎么分配总的目标值是一样的，无法区分</p><p>剩余时间 40min 和剩余时间 35min，无差异，通过其它目标权衡 剩余时间 30 min 和剩余时间 25min，有差异</p><p>剩余时间越少，越要考虑，但权重相同，绝望30min和绝望40min无差异 剩余时间越多，越不考虑，权重为0，剩余30min和剩余40min无差异, 通过其它目标权衡</p><p>超时时长这个指标最大的问题是一刀切了，有超时或没有超时；一旦预估不准，这个就废了</p><p>两个方案加起来剩余时长一样，但线下希望分配最短剩余时长多的方案，所以剩余时长和优先级的关系是非线性的，体现紧急订单的重要性</p><p>20, 10 15, 15 : 第 2 种方案更好</p><h4 id="_1、站点角度-最小化总配送成本【建议】" tabindex="-1">1、站点角度：最小化总配送成本【建议】 <a class="header-anchor" href="#_1、站点角度-最小化总配送成本【建议】" aria-label="Permalink to &quot;1、站点角度：最小化总配送成本【建议】&quot;">​</a></h4><p>即时配送场景下，成本主要意味着效率更高，使用配送路径总程度代替</p><p>优先使用更少的骑手、骑行更短的距离：$\\min \\sum_{i, j} t_{i j} c_{i j}$，其中 $c_{ij}$​ 表示订单 <code>i</code> 由骑手 <code>j</code> 配送的成本（人力成本+运营成本）</p><p>人力成本 = 骑手工作时长 * 时薪（和骑手人数有关）</p><p>运营成本 = 骑行距离 * 电动车运营成本 （和骑行距离有关系）</p><p>综合上面的成本考虑，单均往返时长相比骑手配送人数是更好的指标，用来衡量成本</p><p>骑手人数相同时，单均往返时长短的更优</p><h4 id="_2、用户角度-最小化单均配送时长" tabindex="-1">2、用户角度：最小化单均配送时长 <a class="header-anchor" href="#_2、用户角度-最小化单均配送时长" aria-label="Permalink to &quot;2、用户角度：最小化单均配送时长&quot;">​</a></h4><p>优先分配订单多的：$\\min \\sum_{i, j} t_{i j} x_{i j}$，其中 $t_{ij}$​ 表示订单 <code>i</code> 由骑手 <code>j</code> 配送的时长（预计送达时间 - now）</p><h4 id="_3、用户角度-最大化订单履约时间【建议第一优先级】" tabindex="-1">3、用户角度：最大化订单履约时间【建议第一优先级】 <a class="header-anchor" href="#_3、用户角度-最大化订单履约时间【建议第一优先级】" aria-label="Permalink to &quot;3、用户角度：最大化订单履约时间【建议第一优先级】&quot;">​</a></h4><p>Sum （预约结束-预计送达）/ 订单数，提前量（和目标2有重叠，但效果更好）</p><p>缺点是不能考虑个别紧急订单，优先分配订单紧急的</p><p>平台承诺的订单送达时间长度为 tm , 订单履约时间为 f ij(ωt) ,则 tm - f ij(ωt) 被理解为“节约” 的订单履约时间。 所以,可以得到“节约”的订单履约时间的目标为</p><p><img src="https://muchuang-img.oss-cn-beijing.aliyuncs.com/20240624175243.png" alt=""></p><h4 id="_3、用户角度-最大化剩余可配送时长" tabindex="-1">3、用户角度：最大化剩余可配送时长 <a class="header-anchor" href="#_3、用户角度-最大化剩余可配送时长" aria-label="Permalink to &quot;3、用户角度：最大化剩余可配送时长&quot;">​</a></h4><p>和上面目标重合</p><p>优先按对订单优先级配送，超时权重 * 超时时长（预计送达 &gt; 预约结束-30min 开始考虑）</p><p>超时时长换为紧急订单剩余时长</p><p>最小化所有订单的剩余时间和骑手回店时间之间的差异</p><h4 id="_4、骑手角度-聚集度" tabindex="-1">4、骑手角度：聚集度 <a class="header-anchor" href="#_4、骑手角度-聚集度" aria-label="Permalink to &quot;4、骑手角度：聚集度&quot;">​</a></h4><p>订单聚集度：通过有效的订单分配，降低订单之间的距离，减少骑手在不同地点的频繁移动，提高工作效率。</p><p>小区聚集度：优化配送区域，使得骑手在同一小区内完成更多订单，减少小区的切换，提高工作效率。</p><h4 id="_5、骑手角度-最大化区域顺路程度【建议】" tabindex="-1">5、骑手角度：最大化区域顺路程度【建议】 <a class="header-anchor" href="#_5、骑手角度-最大化区域顺路程度【建议】" aria-label="Permalink to &quot;5、骑手角度：最大化区域顺路程度【建议】&quot;">​</a></h4><p>骑手往返距离</p><h4 id="_7、真实分配订单数" tabindex="-1">7、真实分配订单数 <a class="header-anchor" href="#_7、真实分配订单数" aria-label="Permalink to &quot;7、真实分配订单数&quot;">​</a></h4><p>计算口径：分配给驻店骑手的配送任务</p><p>目标：优先分配配送任务</p><h4 id="_8、骑手偏好-最大化骑手倾向性【建议】" tabindex="-1">8、骑手偏好：最大化骑手倾向性【建议】 <a class="header-anchor" href="#_8、骑手偏好-最大化骑手倾向性【建议】" aria-label="Permalink to &quot;8、骑手偏好：最大化骑手倾向性【建议】&quot;">​</a></h4><p>个性化：全职骑手：高效率订单（可枚举，离散函数）</p><h4 id="_9、用户偏好-最大化用户倾向性【建议】" tabindex="-1">9、用户偏好：最大化用户倾向性【建议】 <a class="header-anchor" href="#_9、用户偏好-最大化用户倾向性【建议】" aria-label="Permalink to &quot;9、用户偏好：最大化用户倾向性【建议】&quot;">​</a></h4><p>个性化：紧急订单：回店早骑手（不可枚举，连续函数）</p><h3 id="三-软约束条件" tabindex="-1">三）软约束条件 <a class="header-anchor" href="#三-软约束条件" aria-label="Permalink to &quot;三）软约束条件&quot;">​</a></h3><p>软约束则可以被适当违反，但通常伴随着某种代价或惩罚</p><p>分层优化：优化主要目标，最后考虑最小化软约束的违反。</p><p>设定一个惩罚函数，当骑手的工作时长超过预设的阈值时，计算超出的时间并乘以一个惩罚系数，将这个值加到目标函数中。</p><h4 id="_1、超骑手背单上限" tabindex="-1">1、超骑手背单上限 <a class="header-anchor" href="#_1、超骑手背单上限" aria-label="Permalink to &quot;1、超骑手背单上限&quot;">​</a></h4><p>分配后-分配前 &gt; 0</p><h4 id="_2、突破区域相关性惩罚" tabindex="-1">2、突破区域相关性惩罚 <a class="header-anchor" href="#_2、突破区域相关性惩罚" aria-label="Permalink to &quot;2、突破区域相关性惩罚&quot;">​</a></h4><p>分配后-分配前</p><p>引入区域相关性和历史跑动趟数，以降低区域的惩罚系数，使得骑手在配送过程中更顺路，提高整体效率</p><p>计算口径：骑手身上后一个订单和前一个订单的区域相关性</p><p>目标：优先分配同区域 -&gt; 相关区域 -&gt; 非相关区域</p><h4 id="_3、时间优先级惩罚" tabindex="-1">3、时间优先级惩罚 <a class="header-anchor" href="#_3、时间优先级惩罚" aria-label="Permalink to &quot;3、时间优先级惩罚&quot;">​</a></h4><p>分配后-分配前</p><p>为什么要违背优先级惩罚？先回店的小哥背单上限低，分给后面回店的小哥可以一趟带走更节省人力</p><p>这个指标不够科学</p><p>timeLoss 最大的问题是基于单个订单，没有考虑前序节，比如下面的 case 中明显右边更难配送</p><p>timeLoss 的优点是压力比较大时，预计送达时间预估并不准，使用 TimeLoss 更科学</p><p><img src="https://muchuang-img.oss-cn-beijing.aliyuncs.com/20240710163624.png" alt=""></p><h4 id="_4、空间优先级惩罚" tabindex="-1">4、空间优先级惩罚 <a class="header-anchor" href="#_4、空间优先级惩罚" aria-label="Permalink to &quot;4、空间优先级惩罚&quot;">​</a></h4><p>分配后-分配前</p><p>同区域给多个骑手，并且骑手还未达到上限</p><p>计算口径：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>for _, riders := range areaRiderCnt {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	if len(riders) &gt; 1 {</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>		// 同区域给多个骑手+1</span></span>
<span class="line"><span>		</span></span>
<span class="line"><span>		solution.Objective.SpaceLoss += len(riders)</span></span>
<span class="line"><span>		</span></span>
<span class="line"><span>		// 骑手没达到背单上限+1</span></span>
<span class="line"><span>		</span></span>
<span class="line"><span>		for r := range riders {</span></span>
<span class="line"><span>		</span></span>
<span class="line"><span>			if len(solution.Results[r].Rider.AssignedJobs)+len(solution.Results[r].Jobs) &lt; solution.Results[r].Rider.Cap {</span></span>
<span class="line"><span>			</span></span>
<span class="line"><span>				solution.Objective.SpaceLoss += 1</span></span>
<span class="line"><span>			</span></span>
<span class="line"><span>			}</span></span>
<span class="line"><span>		}</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>目标：同区域尽量给1个骑手，如果1个骑手带不下，尽可能先让1个骑手达到上限，剩余订单再分派另外一个骑手</p><h3 id="四-硬约束条件" tabindex="-1">四）硬约束条件 <a class="header-anchor" href="#四-硬约束条件" aria-label="Permalink to &quot;四）硬约束条件&quot;">​</a></h3><h4 id="_1、每个订单只能分配给一个骑手" tabindex="-1">1、每个订单只能分配给一个骑手 <a class="header-anchor" href="#_1、每个订单只能分配给一个骑手" aria-label="Permalink to &quot;1、每个订单只能分配给一个骑手&quot;">​</a></h4><p>$\\sum_j x_{i j}=1$，对所有订单 <code>i</code></p><h4 id="_2、订单时间窗约束" tabindex="-1">2、订单时间窗约束 <a class="header-anchor" href="#_2、订单时间窗约束" aria-label="Permalink to &quot;2、订单时间窗约束&quot;">​</a></h4><p>确保订单在规定的时间内送达</p><p>对于每一个订单 <code>i</code>, 有一个时间窗 $\\left[e_i, l_i\\right]$，其中 $e_i$ 是订单 <code>i</code> 的最早可接受配送时间，$l_i$ 是订单 <code>i</code> 的最晚可接受配送时间。</p><p>同时假设 $t_{ij}$ 是骑手 <code>j</code> 从前置仓出发到完成订单 <code>i</code> 的配送所需的时间。</p><p>则时间窗约束可以表示为：</p><p>$e_i \\leq t_{i j} x_{i j} \\leq l_i, \\quad \\forall i, \\forall j$</p><h4 id="_3、骑手的配送能力限制" tabindex="-1">3、骑手的配送能力限制 <a class="header-anchor" href="#_3、骑手的配送能力限制" aria-label="Permalink to &quot;3、骑手的配送能力限制&quot;">​</a></h4><p>$\\sum_i x_{i j} \\leq \\text { Capacity }_j$</p><p>对所有骑手 <code>j</code>，其中 \${ Capacity }_j$ 是骑手 <code>j</code> 的最大配送能力</p><h4 id="_4、骑手载具的重量限制" tabindex="-1">4、骑手载具的重量限制 <a class="header-anchor" href="#_4、骑手载具的重量限制" aria-label="Permalink to &quot;4、骑手载具的重量限制&quot;">​</a></h4><p>$\\sum_i x_{i j} \\leq \\text { Weight }_j$</p><p>对所有骑手 <code>j</code>，其中 \${ Weight }_j$ 是骑手 <code>j</code> 的最大载重量</p><h4 id="_5、骑手顺路程度" tabindex="-1">5、骑手顺路程度 <a class="header-anchor" href="#_5、骑手顺路程度" aria-label="Permalink to &quot;5、骑手顺路程度&quot;">​</a></h4><p>区域个数 订单聚集度 角度 绕路比</p><h2 id="三、模型求解" tabindex="-1">三、模型求解 <a class="header-anchor" href="#三、模型求解" aria-label="Permalink to &quot;三、模型求解&quot;">​</a></h2><h3 id="一-订单召回" tabindex="-1">一）订单召回 <a class="header-anchor" href="#一-订单召回" aria-label="Permalink to &quot;一）订单召回&quot;">​</a></h3><h4 id="_1、待分拣订单" tabindex="-1">1、待分拣订单 <a class="header-anchor" href="#_1、待分拣订单" aria-label="Permalink to &quot;1、待分拣订单&quot;">​</a></h4><p>都不召回</p><h4 id="_2、分拣中订单" tabindex="-1">2、分拣中订单 <a class="header-anchor" href="#_2、分拣中订单" aria-label="Permalink to &quot;2、分拣中订单&quot;">​</a></h4><p>不召回超过 10 分钟未分拣完的订单</p><p>不召回未到最早可处理时间的订单</p><h4 id="_3、待配送订单" tabindex="-1">3、待配送订单 <a class="header-anchor" href="#_3、待配送订单" aria-label="Permalink to &quot;3、待配送订单&quot;">​</a></h4><p>不召回未到最早可处理时间的订单</p><h3 id="二-骑手召回" tabindex="-1">二）骑手召回 <a class="header-anchor" href="#二-骑手召回" aria-label="Permalink to &quot;二）骑手召回&quot;">​</a></h3><h4 id="_1、计算骑手平均负载" tabindex="-1">1、计算骑手平均负载 <a class="header-anchor" href="#_1、计算骑手平均负载" aria-label="Permalink to &quot;1、计算骑手平均负载&quot;">​</a></h4><p>在线压力 / 平均背单上限</p><h4 id="_2、计算召回骑手数" tabindex="-1">2、计算召回骑手数 <a class="header-anchor" href="#_2、计算召回骑手数" aria-label="Permalink to &quot;2、计算召回骑手数&quot;">​</a></h4><p>按照回店顺序召回骑手，直到召回骑手数可剩余背单 * 负载 &gt;= 待分配订单数</p><h4 id="_3、骑手数兜底" tabindex="-1">3、骑手数兜底 <a class="header-anchor" href="#_3、骑手数兜底" aria-label="Permalink to &quot;3、骑手数兜底&quot;">​</a></h4><p>最小骑手数1：对所有区域求和，得到总共需要的骑手数为: 区域单量 / 平均背单上限</p><p>$\\sum_i\\left\\lceil \\frac{n_i}{C_{\\text{avg}}} \\right\\rceil$</p><p>最小骑手数2：所有驻店骑手</p><h3 id="三-人单匹配" tabindex="-1">三）人单匹配 <a class="header-anchor" href="#三-人单匹配" aria-label="Permalink to &quot;三）人单匹配&quot;">​</a></h3><p>分为四个模块</p><h4 id="_1、追单" tabindex="-1">1、追单 <a class="header-anchor" href="#_1、追单" aria-label="Permalink to &quot;1、追单&quot;">​</a></h4><p>遍历骑手，追加与骑士身上同用户的待分配订单</p><p>遍历骑手，追加与骑士身上同小区的待分配订单</p><h4 id="_2、分单" tabindex="-1">2、分单 <a class="header-anchor" href="#_2、分单" aria-label="Permalink to &quot;2、分单&quot;">​</a></h4><p>搜索算法：[[自适应大邻域搜索]] 多目标规划：[[帕累托最优]]</p><h4 id="_3、压单" tabindex="-1">3、压单 <a class="header-anchor" href="#_3、压单" aria-label="Permalink to &quot;3、压单&quot;">​</a></h4><p>骑手未驻店，压一压</p><h4 id="_4、退单" tabindex="-1">4、退单 <a class="header-anchor" href="#_4、退单" aria-label="Permalink to &quot;4、退单&quot;">​</a></h4><p>运力充足防止分配不顺路</p>`,124),p=[i];function o(r,l,h,c,d,_){return n(),e("div",null,p)}const m=a(s,[["render",o]]);export{b as __pageData,m as default};
