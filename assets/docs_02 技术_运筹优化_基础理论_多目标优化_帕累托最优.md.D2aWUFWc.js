import{_ as a,c as n,o as s,a4 as t}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/基础理论/多目标优化/帕累托最优.md","filePath":"docs/02 技术/运筹优化/基础理论/多目标优化/帕累托最优.md"}'),e={name:"docs/02 技术/运筹优化/基础理论/多目标优化/帕累托最优.md"},p=t(`<p>#运筹优化</p><p>在多目标优化问题中，通常存在多个相互冲突的目标，无法找到一个单一的解能够同时最优地满足所有目标。因此，帕累托最优解（也称为非支配解或不受支配解）的概念应运而生</p><p>帕累托最优（Pareto Optimality）是多目标优化中的一个核心概念，<strong>它描述了一种在多个相互冲突的目标之间找到的最佳平衡</strong></p><h2 id="一、概念" tabindex="-1">一、概念 <a class="header-anchor" href="#一、概念" aria-label="Permalink to &quot;一、概念&quot;">​</a></h2><h3 id="_1、非支配解" tabindex="-1">1、非支配解 <a class="header-anchor" href="#_1、非支配解" aria-label="Permalink to &quot;1、非支配解&quot;">​</a></h3><p>假设对所有目标而言，解S1均优于解S2，则称解S1支配解S2</p><p>没有任何解能够支配某个解，则该解称为非支配解</p><h3 id="_2、帕累托前沿-pareto-front" tabindex="-1">2、帕累托前沿（Pareto Front） <a class="header-anchor" href="#_2、帕累托前沿-pareto-front" aria-label="Permalink to &quot;2、帕累托前沿（Pareto Front）&quot;">​</a></h3><p>非支配解的集合即所谓的帕累托前沿</p><h3 id="_3、非支配排序" tabindex="-1">3、非支配排序 <a class="header-anchor" href="#_3、非支配排序" aria-label="Permalink to &quot;3、非支配排序&quot;">​</a></h3><p>非支配排序是一种在多目标优化问题中用来确定解的相对优劣的方法。对种群中的个体进行非支配排序。将种群分为多个等级（Front），第一级包含的是不能被其他任何个体支配的解，第二级包含的是仅被第一级个体支配的解，以此类推。</p><p>1、<strong>计算支配计数和被支配集合</strong>：对于每个个体，计算其被其他个体支配的数量（记为𝑛𝑝​）</p><p>2、<strong>分配非支配等级</strong>：首先找出所有𝑛𝑝=0的个体，将其归入第一层（𝐹1），并赋予它们相同的非支配序值（𝑖𝑟𝑎𝑛𝑘=1）。然后从剩余的种群中继续找出非支配解集，依次分配非支配等级，直到整个种群被分层。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>for i from 1 to |P| do</span></span>
<span class="line"><span>	for j from 0 to i-1 do</span></span>
<span class="line"><span>		# 解 i 更优</span></span>
<span class="line"><span>		如果 P[j] 非支配 P[i] 则</span></span>
<span class="line"><span>			L[i] = L[i] + 1</span></span>
<span class="line"><span>		如果 P[i] 非支配 P[j] 则</span></span>
<span class="line"><span>			 L[j] = max(L[j], L[i] + 1)</span></span>
<span class="line"><span>		end for</span></span>
<span class="line"><span>end for</span></span></code></pre></div><h3 id="_4、拥挤度" tabindex="-1">4、拥挤度 <a class="header-anchor" href="#_4、拥挤度" aria-label="Permalink to &quot;4、拥挤度&quot;">​</a></h3><p>拥挤度（Crowding Distance）是一种用于衡量多目标优化问题中解在目标函数空间分布密度的指标，为了识别和选择那些在目标函数空间中分布较稀疏的解</p><p><strong>计算中间点的拥挤度</strong>：</p><p>Crowding Distancei​= fi+1​−fi​​​  / Maxi​−Mini 其中</p><p>𝑓𝑖fi​ 和 𝑓𝑖+1fi+1​ 是相邻点的目标函数值，Max𝑖Maxi​ 和 Min𝑖Mini​ 是该目标函数的最大值和最小值。</p><p>如果有多个目标函数，每个解的总拥挤度是其在所有目标函数上的拥挤度之和。</p><p>边界点的拥挤度接近于无穷大</p><p>在基于拥挤度选择下一代解时，通常会选择拥挤度最高的解，以保持种群的多样性。</p>`,22),o=[p];function i(r,l,c,d,_,h){return s(),n("div",null,o)}const u=a(e,[["render",i]]);export{m as __pageData,u as default};
