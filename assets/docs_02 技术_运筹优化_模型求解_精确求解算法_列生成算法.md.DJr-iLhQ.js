import{_ as t,c as r,o as a,a4 as o}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型求解/精确求解算法/列生成算法.md","filePath":"docs/02 技术/运筹优化/模型求解/精确求解算法/列生成算法.md"}'),e={name:"docs/02 技术/运筹优化/模型求解/精确求解算法/列生成算法.md"},n=o('<p>列生成算法（Column Generation）是一种专门用于解决大规模线性规划问题的优化技术，特别适用于变量数量极多且难以直接处理的问题。它通过动态生成和添加有潜力改善当前解的变量（列），逐步逼近最优解，从而有效地管理和求解复杂的优化问题。</p><p>列生成算法是基于单纯形法的基本思想改进而来的，要理好解列生成，前提条件是掌握好线性规划单纯形法和对偶问题等知识，主要是单纯形法中非基变量进基时检验数（reduced cost）的计算，对偶问题中的影子价格和对偶变量。</p><p>列生成算法的主要思想是对那些无法列出所有变量的原问题（master problem，MP），先考虑有限变量的主问题restricted master problem (RMP)，其余变量在有需要的时候，再添加到RMP中。什么变量是需要被加入到RMP中的呢？在单纯形法中，我们根据非基变量检验数的正负来选择进基变量；在列生成中，我们通过子问题（subproblem）来寻找满足reduced cost条件的变量，如果找到的话，就将它加入到RMP中，直至找不到为止，那么MP就求得了最优解。</p><p><a href="https://github.com/Operations-Research-Science/Ebook-Linear_Programming/blob/master/docs/chapter5/chapter5.md" target="_blank" rel="noreferrer">https://github.com/Operations-Research-Science/Ebook-Linear_Programming/blob/master/docs/chapter5/chapter5.md</a></p><h3 id="解决问题" tabindex="-1">解决问题 <a class="header-anchor" href="#解决问题" aria-label="Permalink to &quot;解决问题&quot;">​</a></h3><table><thead><tr><th><strong>问题类别</strong></th><th><strong>详细描述</strong></th></tr></thead><tbody><tr><td><strong>大规模线性规划问题</strong></td><td>- 变量数量庞大，直接求解计算资源和时间不可行。<br>- 具有稀疏结构，只有部分变量对最终解有显著影响。</td></tr><tr><td><strong>组合优化问题</strong></td><td>- <strong>车辆路径问题 (VRP)</strong>：优化配送路线，减少运输成本，提高配送效率。<br>- <strong>切割库存问题</strong>：优化材料切割，减少浪费。<br>- <strong>机组调度问题</strong>：优化员工排班，满足运营需求。</td></tr><tr><td><strong>特定结构的优化问题</strong></td><td>- 适用于具有特定约束条件的优化问题，如一类约束下的生成模型。<br>- 分解为主问题和子问题，利用列生成算法高效求解。</td></tr></tbody></table><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><table><thead><tr><th><strong>应用领域</strong></th><th><strong>具体应用</strong></th></tr></thead><tbody><tr><td><strong>运输与物流</strong></td><td>- <strong>车辆路径问题 (VRP)</strong>：优化配送路线，减少运输成本，提高配送效率。<br>- <strong>机组调度</strong>：优化飞行员、司机等资源的排班。</td></tr><tr><td><strong>制造与生产</strong></td><td>- <strong>切割库存问题</strong>：优化材料切割，减少浪费。<br>- <strong>装载优化</strong>：优化货物装载，最大化空间利用率。</td></tr><tr><td><strong>能源与网络</strong></td><td>- <strong>电网优化</strong>：优化电力传输路径，减少能量损失。<br>- <strong>物流网络设计</strong>：优化物流节点布局，提升网络效率。</td></tr></tbody></table><h2 id="算法原理" tabindex="-1">算法原理 <a class="header-anchor" href="#算法原理" aria-label="Permalink to &quot;算法原理&quot;">​</a></h2><p>列生成算法通过迭代的方式处理优化问题，其核心思想包括：</p><ol><li><p><strong>分解问题</strong>：</p><ul><li>将原始的大规模问题分解为一个主问题（Master Problem）和一个子问题（Subproblem）。</li><li><strong>主问题</strong>：包含一个子集的变量（列），用于近似原始问题。</li><li><strong>子问题</strong>：用于生成能够改善当前主问题解的新的变量。</li></ul></li><li><p><strong>迭代求解</strong>：</p><ul><li>初始阶段，主问题只包含少量的变量，通常是一个可行解。</li><li>通过求解主问题，得到一组对偶变量（Dual Variables）。</li><li>利用对偶变量信息，求解子问题以找出新的变量（列），这些变量能够降低目标函数值。</li><li>将新生成的变量添加到主问题中，重复上述过程，直到子问题无法生成任何能够改善当前解的变量为止。</li></ul></li><li><p><strong>收敛性</strong>：</p><ul><li>当子问题无法生成任何进一步改善主问题解的变量时，算法收敛，当前主问题的解即为原始问题的最优解</li></ul></li></ol><h2 id="算法流程图" tabindex="-1">算法流程图 <a class="header-anchor" href="#算法流程图" aria-label="Permalink to &quot;算法流程图&quot;">​</a></h2><p><img src="https://muchuang-img.oss-cn-beijing.aliyuncs.com/20241205223002.png" alt=""></p><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h2><table><thead><tr><th><strong>优点类别</strong></th><th><strong>详细描述</strong></th></tr></thead><tbody><tr><td><strong>高效处理大规模问题</strong></td><td>- 通过按需生成变量，大幅减少计算负担。<br>- 节省内存，适用于变量数量巨大但结构化的优化问题。</td></tr><tr><td><strong>灵活性强</strong></td><td>- 适应不同问题结构，广泛应用于各种组合优化问题。<br>- 可扩展性强，适合动态变化的优化问题。</td></tr><tr><td><strong>提高求解效率</strong></td><td>- 快速逼近最优解，特别是初始可行解较差时效果显著。<br>- 有效利用对偶信息，指导子问题生成更具潜力的变量。</td></tr></tbody></table><h2 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h2><table><thead><tr><th><strong>缺点类别</strong></th><th><strong>详细描述</strong></th></tr></thead><tbody><tr><td><strong>实现复杂性高</strong></td><td>- 需要有效地分解问题，设计合理的列生成策略，具有较高的实现难度。<br>- 子问题求解通常需要专门的算法，可能需要定制化开发。</td></tr><tr><td><strong>收敛速度不稳定</strong></td><td>- 依赖列生成策略设计，策略不合理可能导致收敛缓慢或陷入局部最优。<br>- 可能出现价格停滞问题，导致收敛过程受阻。</td></tr><tr><td><strong>依赖初始解</strong></td><td>- 好的初始可行解能加快收敛，差的初始解可能导致迭代次数增多。<br>- 初始解质量影响算法效率和解的质量。</td></tr><tr><td><strong>维护和调试困难</strong></td><td>- 主问题和子问题协同求解，调试过程可能难以定位问题源头。<br>- 需要细致调整算法参数，增加了维护难度。</td></tr></tbody></table><h2 id="改进方式" tabindex="-1">改进方式 <a class="header-anchor" href="#改进方式" aria-label="Permalink to &quot;改进方式&quot;">​</a></h2><ul><li>采取大规模邻域搜索进行初始路径生成模块，且可异步并行化寻优，为列生成核心模块提供初始寻优较好的初始方向</li><li>传统列生成算法的子问题无并行且一般采取单个子问题计算，本文采取并行化&amp;多子问题算法交叉搜索的方式，可充分释放子问题搜索的多样性/空间，能够进一步提高框架的最优性。</li></ul><h2 id="决策变量" tabindex="-1">决策变量 <a class="header-anchor" href="#决策变量" aria-label="Permalink to &quot;决策变量&quot;">​</a></h2><p>可行路径是否选择</p><h2 id="影子价格" tabindex="-1">影子价格 <a class="header-anchor" href="#影子价格" aria-label="Permalink to &quot;影子价格&quot;">​</a></h2><p>影子价格和对偶变量是一回事，只是在不同背景下使用了不同的名称，<strong>数学优化领域</strong>通常称为对偶变量，<strong>经济学或运筹学应用</strong>中更常称为影子价格。</p><p><strong>从数学角度</strong>： - 对偶变量是伴随原问题的约束产生的变量，它反映了该约束的边际值。 - 在最优解处，对偶变量是原问题中约束的敏感性度量。</p><p><strong>从经济意义</strong>： - 影子价格解释为在约束资源增加一个单位时，对目标函数（如最大化收益或最小化成本）价值的改变量。</p><p>假设有一个线性规划问题： $$ max\\hspace{0.5cm} z = c^T x $$ $$ s.t. Ax≤b, x≥0 $$</p><p>对应的对偶问题是： $$ min\\hspace{0.5cm} w = b^T \\lambda $$ $$ s.t. A^T \\lambda&gt;=c, \\lambda&gt;=0 $$</p><p>其中，对偶变量 $\\lambda$ 就是影子价格。如果某个约束的 $\\lambda_i &gt; 0$，它表示该约束是<strong>紧约束</strong>（Active Constraint），对目标函数有实际贡献，其值表示放宽该约束一单位对目标值的改变量。</p><p>原始问题是最大化问题，对偶问题是最小化问题。 对偶问题变量的数等于原始问题约束的数量。 对偶问题约束的数量等于原始问题变量的数量。 对偶问题的目标函数是原始问题约束右侧值的线性组合，乘以对偶变量。 对偶问题的约束是原始问题系数矩阵的转置与目标函数系数的比较。</p><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><p>1、为什么要引入对偶问题？</p><p>对偶问题变量更少，通常更好求解，转化目标函数和约束条件的形式，目标函数和约束条件互换</p><p>2、是精确求解算法吗？</p><p>如果有数量或时间限制，那么不是严格的精确求解算法</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><p><a href="https://www.cnblogs.com/dengfaheng/p/11249879.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/dengfaheng/p/11249879.html</a></p>',36),s=[n];function d(l,h,i,g,b,c){return a(),r("div",null,s)}const u=t(e,[["render",d]]);export{m as __pageData,u as default};
