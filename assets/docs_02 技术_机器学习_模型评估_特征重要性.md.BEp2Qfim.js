import{_ as t,c as s,o as a,a4 as n}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"一、特征重要性指标","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/机器学习/模型评估/特征重要性.md","filePath":"docs/02 技术/机器学习/模型评估/特征重要性.md"}'),e={name:"docs/02 技术/机器学习/模型评估/特征重要性.md"},p=n(`<h1 id="一、特征重要性指标" tabindex="-1">一、特征重要性指标 <a class="header-anchor" href="#一、特征重要性指标" aria-label="Permalink to &quot;一、特征重要性指标&quot;">​</a></h1><h2 id="_1、三种特征重要性指标解释" tabindex="-1">1、三种特征重要性指标解释 <a class="header-anchor" href="#_1、三种特征重要性指标解释" aria-label="Permalink to &quot;1、三种特征重要性指标解释&quot;">​</a></h2><table><thead><tr><th>名称</th><th>含义</th><th>理解方式</th><th>优劣势</th></tr></thead><tbody><tr><td><strong>split</strong></td><td>特征参与分裂的次数</td><td>“这个特征在多少次决策中被使用”</td><td>✅直观，❌不考虑贡献大小</td></tr><tr><td><strong>gain</strong></td><td>每次使用该特征带来的损失函数的“增益”（之和）</td><td>“这个特征让模型更准确的总功劳”</td><td>✅效果相关，默认推荐</td></tr><tr><td><strong>cover</strong></td><td>使用该特征的叶子节点所覆盖样本数之和</td><td>“这个特征影响了多少数据”</td><td>✅可反映数据覆盖，❌易被高频特征占据</td></tr></tbody></table><p>假设你训练一个 GBDT 模型：</p><table><thead><tr><th>特征</th><th>split 次数</th><th>gain 总值</th><th>cover 总数</th></tr></thead><tbody><tr><td>A</td><td>20</td><td>100</td><td>10,000</td></tr><tr><td>B</td><td>5</td><td>120</td><td>3,000</td></tr></tbody></table><ul><li><p><strong>split</strong> 会说：A 比较重要（出现得多）；</p></li><li><p><strong>gain</strong> 会说：B 更重要（每次出现都很有用）；</p></li><li><p><strong>cover</strong> 会说：A 更影响整体（分裂时覆盖样本多）；</p></li></ul><p>所以，它们关注的角度是：</p><ul><li><p>split → <em>频率</em></p></li><li><p>gain → <em>效益</em></p></li><li><p>cover → <em>影响范围</em></p></li></ul><h1 id="二、lightgbm-xgboost-默认使用哪种" tabindex="-1">二、LightGBM/XGBoost 默认使用哪种 <a class="header-anchor" href="#二、lightgbm-xgboost-默认使用哪种" aria-label="Permalink to &quot;二、LightGBM/XGBoost 默认使用哪种&quot;">​</a></h1><p>LightGBM 和 XGBoost 默认使用的是：split</p><table><thead><tr><th>目的</th><th>推荐指标</th><th>原因</th></tr></thead><tbody><tr><td>解释预测效果</td><td>✅ <code>gain</code></td><td>与性能提升直接相关，避免“频繁但无效”的特征</td></tr><tr><td>特征筛选（降维）</td><td>✅ <code>gain</code> + <code>split</code></td><td>先看 gain，再考虑使用频率</td></tr><tr><td>识别样本覆盖</td><td><code>cover</code></td><td>比较次要，常用于补充判断</td></tr></tbody></table><p>随机森林</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>from sklearn.ensemble import RandomForestRegressor</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 用随机森林初步评估特征重要性</span></span>
<span class="line"><span>X = data.drop(columns=[&#39;exam_score&#39;])</span></span>
<span class="line"><span>y = data[&#39;exam_score&#39;]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>rf = RandomForestRegressor(n_estimators=100, random_state=42)</span></span>
<span class="line"><span>rf.fit(X, y)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 查看重要性</span></span>
<span class="line"><span>importances = pd.DataFrame({</span></span>
<span class="line"><span>    &#39;feature&#39;: X.columns,</span></span>
<span class="line"><span>    &#39;importance&#39;: rf.feature_importances_</span></span>
<span class="line"><span>}).sort_values(&#39;importance&#39;, ascending=False)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print(importances.head(10))</span></span></code></pre></div><p>Lightgbm</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>from lightgbm import LGBMRegressor</span></span>
<span class="line"><span>model = LGBMRegressor(n_estimators=1000, learning_rate=0.05, max_depth=6, subsample=0.8, colsample_bytree=0.8)</span></span>
<span class="line"><span>model.fit(X_train, y_train, eval_set=[(X_test, y_test)], early_stopping_rounds=100, verbose=0)</span></span>
<span class="line"><span>print(&#39;R2 =&#39;, model.score(X_test, y_test))</span></span></code></pre></div>`,15),d=[p];function o(l,r,i,c,h,_){return a(),s("div",null,d)}const b=t(e,[["render",o]]);export{m as __pageData,b as default};
