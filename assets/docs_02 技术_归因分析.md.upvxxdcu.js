import{_ as t,c as e,o as l,a4 as o}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"一、第一性原理出发点","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/归因分析.md","filePath":"docs/02 技术/归因分析.md"}'),a={name:"docs/02 技术/归因分析.md"},p=o('<h1 id="一、第一性原理出发点" tabindex="-1">一、第一性原理出发点 <a class="header-anchor" href="#一、第一性原理出发点" aria-label="Permalink to &quot;一、第一性原理出发点&quot;">​</a></h1><p><strong>总原理</strong>：</p><blockquote><p>总变化 = 结构变化引起的变化 + 能力变化引起的变化 + 其他因素</p></blockquote><p>或者更数学化：</p><p>ΔY=结构变化影响⏟样本/请求/点位分布变化+能力变化影响⏟算法/策略本身性能变化+干扰因素⏟季节、城市、随机波动\\Delta Y = \\underbrace{\\text{结构变化影响}}<em>{\\text{样本/请求/点位分布变化}} + \\underbrace{\\text{能力变化影响}}</em>{\\text{算法/策略本身性能变化}} + \\underbrace{\\text{干扰因素}}_{\\text{季节、城市、随机波动}}ΔY=样本/请求/点位分布变化结构变化影响​​+算法/策略本身性能变化能力变化影响​​+季节、城市、随机波动干扰因素​​</p><p>这里：</p><ul><li><p><strong>Y</strong>：你关心的指标（周转、订单量、收益等）</p></li><li><p><strong>结构变化</strong>：样本组成变化（新增请求、点位占比变化、长尾点位增加等）</p></li><li><p><strong>能力变化</strong>：算法、策略、模型本身性能变化</p></li><li><p><strong>干扰因素</strong>：天气、节假日、运营策略等</p></li></ul><p><strong>第一性原理思路就是：总变化 = 每个因子贡献之和</strong>。</p><hr><h1 id="二、四步拆解流程-第一性原理归因" tabindex="-1">二、四步拆解流程（第一性原理归因） <a class="header-anchor" href="#二、四步拆解流程-第一性原理归因" aria-label="Permalink to &quot;二、四步拆解流程（第一性原理归因）&quot;">​</a></h1><h3 id="step-1-明确总变化" tabindex="-1"><strong>Step 1：明确总变化</strong> <a class="header-anchor" href="#step-1-明确总变化" aria-label="Permalink to &quot;**Step 1：明确总变化**&quot;">​</a></h3><ul><li><p>定义指标：周转、订单量、成交率等</p></li><li><p>定义时间窗口：12 月 vs 1 月</p></li><li><p>计算总变化：</p></li></ul><p>ΔY=Ynew−Yold\\Delta Y = Y_{new} - Y_{old}ΔY=Ynew​−Yold​</p><blockquote><p>这一点是前提：先量化总变化，才有归因意义。</p></blockquote><hr><h3 id="step-2-拆分结构变化" tabindex="-1"><strong>Step 2：拆分结构变化</strong> <a class="header-anchor" href="#step-2-拆分结构变化" aria-label="Permalink to &quot;**Step 2：拆分结构变化**&quot;">​</a></h3><ul><li><p>核心思路：新增 / 减少 / 权重变化对指标的影响</p></li><li><p>方法：</p></li></ul><ol><li><p>识别“样本结构”维度（点位、请求、城市等）</p></li><li><p>拆成旧样本（base） vs 新增样本（add）</p></li><li><p>用旧权重计算理论指标，得到结构贡献：</p></li></ol><p>结构贡献=Y结构变化模拟−Y旧\\text{结构贡献} = Y_{\\text{结构变化模拟}} - Y_{\\text{旧}}结构贡献=Y结构变化模拟​−Y旧​</p><blockquote><p>这一步回答了：“总变化中，有多少是因为样本组合变了？”</p></blockquote><hr><h3 id="step-3-拆分能力变化" tabindex="-1"><strong>Step 3：拆分能力变化</strong> <a class="header-anchor" href="#step-3-拆分能力变化" aria-label="Permalink to &quot;**Step 3：拆分能力变化**&quot;">​</a></h3><ul><li><p>核心思路：结构校正后仍有变化，就是算法/策略本身能力变化</p></li><li><p>方法：</p></li></ul><p>能力贡献=Y真实−Y结构校正模拟\\text{能力贡献} = Y_{\\text{真实}} - Y_{\\text{结构校正模拟}}能力贡献=Y真实​−Y结构校正模拟​</p><ul><li><p>进一步可以拆到阶段或环节（召回 vs 排序），甚至拆到点位级别</p></li><li><p>这一步回答了：“算法本身性能是升是降？”</p></li></ul><hr><h3 id="step-4-考虑干扰因素-验证" tabindex="-1"><strong>Step 4：考虑干扰因素 &amp; 验证</strong> <a class="header-anchor" href="#step-4-考虑干扰因素-验证" aria-label="Permalink to &quot;**Step 4：考虑干扰因素 &amp; 验证**&quot;">​</a></h3><ul><li><p>核心思路：剔除非算法相关的外部因素</p></li><li><p>方法：</p></li></ul><ol><li><p>偏差校正：节假日、天气、城市结构</p></li><li><p>回测历史同周期变化（季节性）</p></li><li><p>校验归因结果合理性（检查比例是否超过 100% 或负贡献异常）</p></li></ol><blockquote><p>这一步保证归因解释可靠，不会把“外部偶然因素”误判为算法问题。</p></blockquote><hr><h1 id="三、可视化表达-逻辑图" tabindex="-1">三、可视化表达（逻辑图） <a class="header-anchor" href="#三、可视化表达-逻辑图" aria-label="Permalink to &quot;三、可视化表达（逻辑图）&quot;">​</a></h1><p><code>总变化 ΔY ├── 结构变化贡献 ΔY_structure │ ├─ 新增请求 / 样本占比变化 │ └─ 点位/城市分布变化 ├── 算法/策略能力变化 ΔY_ability │ ├─ 召回能力变化 │ └─ 排序能力变化 └── 外部干扰 ΔY_noise ├─ 节假日 / 天气 / 活动 └─ 随机波动</code></p><hr><h1 id="四、关键原则-第一性原理" tabindex="-1">四、关键原则（第一性原理） <a class="header-anchor" href="#四、关键原则-第一性原理" aria-label="Permalink to &quot;四、关键原则（第一性原理）&quot;">​</a></h1><ol><li><p><strong>总变化必须量化</strong> → 否则归因没有参照</p></li><li><p><strong>先拆结构，再拆能力</strong> → 结构变化是最容易混淆的因子</p></li><li><p><strong>分层递进</strong> → 链路 → 阶段 → 点位 → 请求</p></li><li><p><strong>外部因素单独考虑</strong> → 避免把自然波动当成算法退化</p></li><li><p><strong>可量化 &amp; 可校验</strong> → 每个拆分步骤，都能用数据算出 ΔY 的贡献</p></li></ol><hr><h1 id="五、对你当前场景的映射" tabindex="-1">五、对你当前场景的映射 <a class="header-anchor" href="#五、对你当前场景的映射" aria-label="Permalink to &quot;五、对你当前场景的映射&quot;">​</a></h1><ul><li><p><strong>总变化</strong>：新链路 1 月 vs 12 月周转下降</p></li><li><p><strong>结构变化</strong>：新增请求（20%）、点位分布变化</p></li><li><p><strong>能力变化</strong>：排序阶段周转下降</p></li><li><p><strong>干扰因素</strong>：节假日、城市占比变化等</p></li></ul><blockquote><p>所以第一步必然是：先定位新增请求（结构拆分第一步），再量化排序能力变化。</p></blockquote>',40),r=[p];function i(s,n,h,c,d,u){return l(),e("div",null,r)}const b=t(a,[["render",i]]);export{g as __pageData,b as default};
