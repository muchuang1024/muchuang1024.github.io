import{_ as o,c as a,o as e,a4 as d,m as t,a as r}from"./chunks/framework.4aTu-Nia.js";const u=JSON.parse('{"title":"三、算法方案","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型应用/共享单车/冗余调度.md","filePath":"docs/02 技术/运筹优化/模型应用/共享单车/冗余调度.md"}'),n={name:"docs/02 技术/运筹优化/模型应用/共享单车/冗余调度.md"},s=d('<h2 id="一、问题定义" tabindex="-1">一、问题定义 <a class="header-anchor" href="#一、问题定义" aria-label="Permalink to &quot;一、问题定义&quot;">​</a></h2><p>单车在冗余点位存在大量闲置车辆，这部分闲置车辆如无人为干预，往往会导致大量的单车资产闲置浪费。通过冗余点调度的能力建设，可以将闲置车从冗余点位转移到其他有缺口的好点上，提升闲置车辆的流动和周转，并为单车业务带来更多的骑行收入和订单</p><p>我们要决定如何将<strong>点位的冗余需求</strong>转化为<strong>可执行的工单组</strong>，并将这些工单组<strong>分配给有限的司机</strong>，同时确定<strong>每个工单组内部的点位访问顺序和调度量</strong></p><table><thead><tr><th>业务场景</th><th>输入参数</th><th>算法目标&amp;约束</th><th>输出</th></tr></thead><tbody><tr><td>冗余点调度</td><td><strong>点位信息</strong>：<br><br>- 点位冗余<br> <br>- 点位可用司机<br> <br><br><strong>司机信息</strong>：<br><br>- 司机排班范围<br> <br>- 司机位置<br> <br>- 司机应生单量<br> <br>- 司机的载具信息<br> <br> - 载具大类（计算应生单量）<br> <br> - 载具容量<br> <br> - 载具最大工单距离<br> <br><br><strong>距离矩阵：</strong><br><br>- 点位到点位<br> <br>- 点位到司机</td><td><strong>目标函数</strong>：<br><br>- <strong>主目标</strong>：最大化派发量<br> <br>- <strong>次目标</strong>：最小化总工单组距离<br> <br><br><strong>约束条件</strong>：<br><br>1. 点位约束<br> <br> - 点位冗余约束：每个点位调出的总单车数不能超过其冗余量<br> <br> <br> - 最小调度量约束：工单组中每个点位存在最小调度数量 &gt;= X<br> <br>2. 司机约束<br> <br> - 司机最大工单数约束：每个司机最多承接的工单数<br> <br>3. 工单组约束<br> <br> - 工单组点位类型约束：<br> <br> - 全部为校园点位或者非校园点位<br> <br> - 工单组内的校园点位要在同1个校园围栏下<br> <br> - 工单组容量约束：工单组装车数 &lt;= 分配司机载具容量<br> <br> - 工单组满载率约束：工单组车辆数 &gt;= 分配司机载具容量 * 满载率<br> <br> -工单组访问点位数：工单组访问点位数 &lt;= 分配司机载具最大点位数<br> <br> - 工单组最大距离约束：工单组最大距离 &lt;= 分配司机载具最大距离 * 系数<br> <br>4. 司机 × 点位匹配约束<br> <br> - 司机作业范围约束：工单组第一个装点在司机排班范围内<br> <br> - 点位可停靠载具约束：司机载具类型“不是”点位不可停靠载具类型</td><td>司机-工单组匹配结果</td></tr></tbody></table><h2 id="二、问题建模" tabindex="-1">二、问题建模 <a class="header-anchor" href="#二、问题建模" aria-label="Permalink to &quot;二、问题建模&quot;">​</a></h2><h2 id="_1、-核心集合-sets" tabindex="-1">1、 核心集合 (Sets) <a class="header-anchor" href="#_1、-核心集合-sets" aria-label="Permalink to &quot;1、 核心集合 (Sets)&quot;">​</a></h2><p>定义参与调度的实体和点位类型。</p><table><thead><tr><th>概念</th><th>集合符号</th><th>元素符号 (下标)</th><th>描述</th></tr></thead><tbody><tr><td>司机 (Driver)</td><td>D</td><td>$d \\in D$</td><td>司机（Driver）集合</td></tr><tr><td>工单 (Order)</td><td>O</td><td>$o \\in O$</td><td><strong>潜在工单</strong> (Order) 集合</td></tr><tr><td>点位 (Fence)</td><td>F</td><td>$f \\in f$</td><td>冗余点位（Fence/Pick-up）集合</td></tr><tr><td>扩展点位集合</td><td>FF</td><td>$FF = F \\cup D$</td><td>点位 + 司机</td></tr><tr><td>街道 (Street）</td><td>S</td><td>$s \\in S$</td><td>街道（Street）集合</td></tr></tbody></table><h2 id="_2、-核心参数-parameters" tabindex="-1">2、 核心参数 (Parameters) <a class="header-anchor" href="#_2、-核心参数-parameters" aria-label="Permalink to &quot;2、 核心参数 (Parameters)&quot;">​</a></h2><p>定义已知的输入数据和限制条件。</p><table><thead><tr><th>符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>Redundancy​</td><td>点位 k∈F 的冗余车辆数</td><td>冗余量</td></tr><tr><td>Capacity_d​</td><td>工单 i∈I 对应的载具容量。</td><td>车辆容量</td></tr><tr><td>MinRate_d​</td><td>司机 j∈D 可分配的最大工单数。</td><td>Multi-trip 限制</td></tr><tr><td>MaxFenceNum​</td><td>点位 k 到点位 l 的距离成本。</td><td>距离矩阵</td></tr><tr><td>MinLoadNum​</td><td>允许的最大总距离限制。</td><td>路径距离上限</td></tr><tr><td>MaxOrderNum_d​</td><td>工单的满载率下限。</td><td>0.8 (80%)</td></tr><tr><td>MaxDistance_​</td><td>如果点位 k 是校园点位则为 1，否则为 0。</td><td>校园标签</td></tr><tr><td>AllowVisit_df​</td><td>二元参数，司机 j 是否被允许访问点位 k（区域/技能兼容）。</td><td>技能矩阵</td></tr><tr><td>StreetMaxLoadNum​</td><td>街道 S 的最大允许装车数</td><td>923 维度的约束</td></tr></tbody></table><h2 id="_3、-决策变量-variables" tabindex="-1">3、 决策变量 (Variables) <a class="header-anchor" href="#_3、-决策变量-variables" aria-label="Permalink to &quot;3、 决策变量 (Variables)&quot;">​</a></h2><p>建模时<strong>预设一个工单池 $O$</strong>，然后让求解器决定<strong>从 O 中选择哪些工单</strong>来完成任务，以及<strong>将选中的工单分配给哪个司机</strong>。理论最大工单数 = 总冗余数 /（最小载具容量 * 满载率）</p><table><thead><tr><th>符号</th><th>变量</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>$x_{od}$</td><td>工单分配</td><td>工单 o 是否分配给司机 d</td><td>二元 (0/1)</td></tr><tr><td>$s_{o,f,l}$</td><td>工单路径</td><td>工单 $o$ 中，点位 $f$ 紧接在点位 $l$ 之后</td><td>二元 (0/1)</td></tr><tr><td>$y_{of}$</td><td>工单访问点位</td><td>工单 o 是否访问点位 f</td><td>二元 (0/1)</td></tr><tr><td>$q_{of}$​</td><td>工单装车数</td><td>工单 i 在点位 f 装车数</td><td>整数</td></tr><tr><td>$z_o$</td><td>工单 o 选中</td><td>工单 $o$ 被使用（1/0）</td><td>二元 (0/1)</td></tr></tbody></table><h2 id="_4、目标函数" tabindex="-1">4、目标函数 <a class="header-anchor" href="#_4、目标函数" aria-label="Permalink to &quot;4、目标函数&quot;">​</a></h2><p>问题采用<strong>分层（优先级）优化</strong>，最终目标是<strong>最小化距离</strong>，同时确保<strong>未派发工单数尽可能低</strong></p><p>$$ \\min \\lambda {Order}_{\\text{Unassigned}} + TotalDist $$</p><p>P0： 最大化 T0 司机装车量 $$\\max Z_0 = \\sum_{d \\in D_{T0}} \\sum_{o \\in O} \\sum_{f \\in F} q_{of} \\cdot x_{od}$$ P0： 最小化未派发工单数</p><p>$$ \\min \\text{Order}<em>{\\text{Unassigned}} = \\sum</em>{o \\in O} (1 - z_o)$$</p><p>P1： 最小化总调度距离</p><blockquote><p>司机当前位置到其工单第一个装车点的距离 + 工单内部装车点之间的距离</p></blockquote><p>$$\\min TotalDist = \\sum_{d \\in D} \\sum_{o \\in O} x_{od} \\cdot Distance_{d, \\text{start}(o)} + \\sum_{o \\in O} \\sum_{f \\in F} \\sum_{l \\in F, f \\ne l} Distance_{f,l} \\cdot s_{o,f,l}$$</p><p>$Distance_{d, \\text{start}(o)}$: 司机 $d$ 当前位置到工单 $o$ 中第一个装车点的距离</p><p>$\\lambda$ 的取值主要遵循<strong>大 M 法 (Big M Method)</strong> 的思想，目的是确保高优先级目标（P0/最小化 $\\text{Order}_{\\text{Unassigned}}$）总是比低优先级目标（P1/最小化 $\\text{TotalDist}$）优先得到优化</p><p>$\\lambda$ 取值过大或过小的风险</p><table><thead><tr><th><strong>风险</strong></th><th><strong>λ​ 取值</strong></th><th><strong>影响</strong></th></tr></thead><tbody><tr><td><strong>优先级颠倒</strong></td><td><strong>过小</strong>（例如 $\\lambda_{U} = 100$）</td><td>求解器可能为了节省 200 公里的距离，而接受多出一个未派发工单（惩罚仅增加 $100$），<strong>违反了 P0 的最高优先级</strong>。</td></tr><tr><td><strong>数值溢出/不稳定</strong></td><td><strong>过大</strong>（例如 $\\lambda_{U} = 10^{15}$）</td><td>虽然理论上成立，但在计算机浮点运算中，过大的 $\\lambda$ 可能导致<strong>数值精度问题</strong>，使 TotalDist 的变化被淹没，求解器难以判断距离上的微小优化。</td></tr></tbody></table><p>$\\lambda_{U}$ 的理论下界计算：最大点位距离</p><p>我们必须确保：<strong>减少一个未派发工单带来的收益</strong>（即 $\\lambda_{U} \\cdot 1$）<strong>大于</strong> $\\text{TotalDist}$ 在所有可行解中可能增加的<strong>最大距离成本</strong>。 $$\\lambda_{U} &gt; \\text{Max}(\\text{TotalDist}) - \\text{Min}(\\text{TotalDist}) \\approx \\text{Max}(\\text{TotalDist})$$</p><p>$\\lambda_{L}$ 的理论上界计算：$50e3$</p><p>$\\lambda$ 最终取值 max (maxDist， 50e3)</p><h2 id="_5、约束条件" tabindex="-1">5、约束条件 <a class="header-anchor" href="#_5、约束条件" aria-label="Permalink to &quot;5、约束条件&quot;">​</a></h2><p>该模型是一个复杂的<strong>带拆分配送、多程和技能约束的 VRP/指派问题</strong></p><h4 id="a-点位约束" tabindex="-1">A. 点位约束 <a class="header-anchor" href="#a-点位约束" aria-label="Permalink to &quot;A. 点位约束&quot;">​</a></h4><p>1）冗余量上限： 任何点位 $k$ 上的总装车量不能超过其冗余车辆数。 $$\\sum_{o} q_{of} \\le \\text{Redundancy}_f \\quad \\forall f \\in F $$</p><p>2）最小调度量约束： $$q_{of} \\ge MinLoadNum \\cdot y_{of}, \\quad \\forall o \\in O, f \\in F$$</p><p>3）街道最大装车数约束 (Street Maximum Load):</p><p>$$\\sum_{f \\in F: \\text{Street}<em>f = S} \\sum</em>{o \\in O} q_{of} \\le \\text{StreetMaxLoadNum}_S, \\quad \\forall S \\in \\text{Streets}$$</p><p><em>外层求和 ($\\sum_{f \\in F: \\text{Street}_f = S}$): 聚合所有属于特定街道 $S$</em>* 的点位 $f$。 <strong>内层求和 ($\\sum_{o \\in O} q_{of}$): 计算在点位 $f$ 上所有工单 $o$ 的</strong>总装载量。 约束体: 确保这个总和不超过该街道的硬性限制 $\\text{StreetMaxLoadNum}_S$</p><h3 id="b-司机约束" tabindex="-1">B. 司机约束 <a class="header-anchor" href="#b-司机约束" aria-label="Permalink to &quot;B. 司机约束&quot;">​</a></h3><p>3）司机最大工单数约束 (Maximum Trips per Driver): 每个司机 $d$ 承接的工单数不能超过其上限</p><p>$$\\sum_{o \\in O} x_{od} \\le MaxOrderNum_d, \\quad \\forall d \\in D$$</p><h3 id="c-工单组约束" tabindex="-1">C. 工单组约束 <a class="header-anchor" href="#c-工单组约束" aria-label="Permalink to &quot;C. 工单组约束&quot;">​</a></h3><p>工单 $o$ 的属性（容量、点位数限制、距离限制）都依赖于它被分配到的<strong>司机 $d$ 的载具属性</strong></p><p>1）工单组容量约束 (Capacity Upper Bound): 工单 $o$ 的装车数不超过分配给它的司机 $d$ 的载具容量 $Capacity_d$</p><p>$$\\sum_{f \\in F} q_{of} \\le \\sum_{d \\in D} Capacity_d \\cdot x_{od}, \\quad \\forall o \\in O$$</p><p>2）工单组满载率约束 (Minimum Load): 工单 $o$ 的装车数不低于分配给它的司机 $d$ 的载具容量 $Capacity_d$ 乘以满载率</p><p>$$\\sum_{f \\in F} q_{of} \\ge \\sum_{d \\in D} (Capacity_d \\cdot MinRate_{d}) \\cdot x_{od}, \\quad \\forall o \\in O$$</p><p>3）工单组访问点位数： 工单 $o$ 访问的点位数不超过分配给它的司机 $d$ 的载具最大点位数</p>',48),$=t("p",null,[r("$$\\sum_{f \\in F} y_{of} \\le \\sum_{d \\in D} \\text{MaxFenceNum}"),t("em",{od:""},"d \\cdot x"),r(", \\quad \\forall o \\in O$$")],-1),i=d('<p>4）工单组最大距离约束 (Maximum Distance): 工单 $o$ 的总距离（起始点到第一个装点 + 内部路径）不超过司机 $d$ 载具最大距离乘以系数</p><p>$$\\sum_{d \\in D} x_{od} \\cdot Distance_{d, \\text{start}(o)} + \\sum_{f \\in F} \\sum_{l \\in F, f \\ne l} Distance_{f,l} \\cdot s_{o,f,l} \\le \\sum_{d \\in D} (MaxDistance_{d} \\cdot \\text{Coeff}) \\cdot x_{od}, \\quad \\forall o \\in O$$</p><h3 id="d-司机-×-点位匹配约束" tabindex="-1">D. 司机 × 点位匹配约束 <a class="header-anchor" href="#d-司机-×-点位匹配约束" aria-label="Permalink to &quot;D. 司机 × 点位匹配约束&quot;">​</a></h3><p>需要在预处理阶段定义一个<strong>能力匹配矩阵 $AllowVisit_{df}$</strong>，它整合了所有地理和技能上的限制</p><p><strong>参数 $AllowVisit_{df}$：</strong> 二元参数，如果<strong>司机 $d$ 被允许访问点位 $f$</strong>，则 $AllowVisit_{df} = 1$，否则 $AllowVisit_{df} = 0$</p><table><thead><tr><th><strong>限制类型</strong></th><th><strong>逻辑判断（如果满足，则 Adf​=1）</strong></th></tr></thead><tbody><tr><td><strong>地理/排班区域 (1023点位)</strong></td><td>点位 $f$ 位于司机 $d$ 排班的 923/921 区域对应的 1023 范围内</td></tr><tr><td><strong>不可停靠车辆类型</strong></td><td>司机 $d$ 载具的类型<strong>不是</strong>点位 $f$ 的不可停靠载具类型</td></tr></tbody></table><p>1）<strong>司机作业范围约束 (First Stop Range):</strong> 工单组 $o$ 的**第一个装点必须在司机 $d$ 的排班范围内</p><p>2）点位可停靠载具约束 (Vehicle Type Compatibility): 司机 $d$ 的载具类型必须是点位 $f$ 允许停靠的类型 $$y_{of} + x_{od} \\le 1 + AllowVisit_{df}, \\quad \\forall o \\in O, d \\in D, f \\in F$$</p><p>司机 d 可以访问点位 f 时，工单 o 包含点位 f 和 工单 o 分配给司机 d 不能同时满足</p><h3 id="e-路径约束" tabindex="-1">E. 路径约束 <a class="header-anchor" href="#e-路径约束" aria-label="Permalink to &quot;E. 路径约束&quot;">​</a></h3><p>路径连续性和子回路消除，保证 $s_{o,f,l}$ 和 $s_{o,l,f}$ 不同时为 1，避免目标函数或者约束重复计算</p><p>起点约束</p><p>终点约束</p><p>流平衡 - 每个访问点位，必须有且只有一条路径进入（遍历客户点，不包含起点 depot 和终点 depot） （<strong>封闭 VRP</strong>，开放式 VRP 增加虚拟点变成封闭 VRP）</p><p>$$\\sum_{l \\in F, l \\ne f} s_{o,l,f} = y_{of}, \\quad \\forall o \\in O, f \\in F$$</p><p>流平衡 - 每个访问点位，必须有且只有一条路径离开（遍历客户点，不包含起点 depot 和终点 depot）</p><p>$$\\sum_{l \\in F, l \\ne f} s_{o,f,l} = y_{of}, \\quad \\forall o \\in O, f \\in F$$</p><p>子回路消除: 确保访问点位 $f$ 形成有效路径，引入 MTZ 等约束</p><p>$$u_{of} - u_{ol} + N \\cdot s_{o,f,l} \\le N - 1, \\quad \\forall o \\in O, f, l \\in F, f \\ne l$$</p><h3 id="f-逻辑约束" tabindex="-1">F. 逻辑约束 <a class="header-anchor" href="#f-逻辑约束" aria-label="Permalink to &quot;F.  逻辑约束&quot;">​</a></h3><p>确保未使用的工单不被分配，且被分配的工单必须装载</p><p>1）工单使用激活: $$\\sum_{f \\in F} q_{of} \\le M \\cdot z_o, \\forall o \\in O $$ 2）工单分配:</p><p>$$\\sum_{d \\in D} x_{od} = z_o, \\forall o \\in O $$</p><p>3）工单访问激活:</p><p>$$q_{of} \\le M \\cdot y_{of}, \\forall o \\in O, f \\in F $$</p><p>4）工单第一个点位：</p><h1 id="三、算法方案" tabindex="-1">三、算法方案 <a class="header-anchor" href="#三、算法方案" aria-label="Permalink to &quot;三、算法方案&quot;">​</a></h1><p><a href="https://www.processon.com/embed/693c1cc9806d9b26fb675d5c" target="_blank" rel="noreferrer">https://www.processon.com/embed/693c1cc9806d9b26fb675d5c</a></p>',28),l=[s,$,i];function _(p,b,h,f,c,m){return e(),a("div",null,l)}const x=o(n,[["render",_]]);export{u as __pageData,x as default};
