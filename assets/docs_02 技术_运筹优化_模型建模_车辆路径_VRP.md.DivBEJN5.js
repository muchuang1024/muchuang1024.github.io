import{_ as l,c as n,o as s,a4 as o,m as i,a as t}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型建模/车辆路径/VRP.md","filePath":"docs/02 技术/运筹优化/模型建模/车辆路径/VRP.md"}'),_={name:"docs/02 技术/运筹优化/模型建模/车辆路径/VRP.md"},e=o("<p><strong>目标：</strong> 最小化车辆总行驶距离</p><p><strong>集合：</strong></p><ul><li>顾客节点 $i, j \\in N = {0, 1, \\dots, n}; \\quad 0 \\text{ 为仓库}$</li><li>边 $(i,j)$</li></ul><p><strong>参数：</strong></p><ul><li>$c_{ij}$：距离或成本</li><li>$q_{j}$：顾客需求</li><li>$Q$：车辆容量</li><li>$K$: 车辆数</li></ul><p><strong>变量：</strong></p><ul><li>$x_{ij}^{k}$ 辆 k 是否从 i 到 j</li><li>$u_{i}$: 车辆到达客户 $i$ 时的剩余负荷（用来消除子环）</li></ul><p><strong>模型（CVRP + MTZ）：</strong></p><p>目标：最小化总成本</p><p>$$min \\sum_{k = 1} ^ {K} \\sum_{i \\in I} \\sum_{j \\in J } c_{ij} x_{ij}^k $$</p><p>约束：每个客户点必须只被访问一次</p><p>$$\\sum_{k = 1} ^ {K} \\sum_{i \\in N} x_{ij} ^ k = 1, \\quad \\forall j \\neq 0 $$</p><p>约束：车辆起终点</p><p>$$\\sum_{j \\in V} x_{0j}^{k} = 1, \\quad \\sum_{i \\in N} x_{i0}^{k} = 1, \\quad \\forall k$$</p><p>约束：流平衡约束</p><p>$$ \\sum_{i \\in N} x_{ij}^{k} = \\sum_{i \\in N} x_{ji} ^ {k}, \\quad \\forall j, k $$</p><p>约束：子路径消除和累积负荷 &lt;= 车辆容量 （MTZ）约束 [[CVRP 容量型 MTZ 约束]]</p>",17),p=i("p",null,[t("$$\\mathbf{u}_i - \\mathbf{u}"),i("em",{ij:""},"j + Q \\cdot x"),t("^k \\leq Q - q_j \\quad \\forall i, j \\in N \\setminus {0}, i \\neq j, \\forall k \\in K$$")],-1),$=i("p",null,"约束：决策变量约束",-1),a=i("p",null,"$$x_{ij}^{k} \\in {0, 1}, \\forall i, j, k $$",-1),r=i("blockquote",null,[i("p",null,[t("当"),i("strong",null,"所有客户的总需求"),t("超过了"),i("strong",null,"所有可用车辆的最大载重总和"),t("时，即使每辆车都满载，也无法运送完所有货物，实际不可能做到，会转换为如下问题：")]),i("p",null,[t("1、未服务惩罚问题 [[P-VRP]] 2、Multi-Trip VRP（允许让车辆多次返回仓库进行补给）[[Multi-Trip VRP]] 3、异构 VRP （原始车队容量不足时，在模型中加入一个"),i("strong",null,"外部车辆"),t("集合，它们有更高的使用成本。模型只有在自有车辆无法完成任务时，才会选择使用这些成本更高的外部车辆）[[异构车队 VRP]]")])],-1),u=[e,p,$,a,r];function c(d,m,j,k,V,f){return s(),n("div",null,u)}const x=l(_,[["render",c]]);export{g as __pageData,x as default};
