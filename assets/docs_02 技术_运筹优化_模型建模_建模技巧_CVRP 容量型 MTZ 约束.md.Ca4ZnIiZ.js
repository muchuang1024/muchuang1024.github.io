import{_ as o,c as i,o as s,a4 as $,m as t,a as _}from"./chunks/framework.4aTu-Nia.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/运筹优化/模型建模/建模技巧/CVRP 容量型 MTZ 约束.md","filePath":"docs/02 技术/运筹优化/模型建模/建模技巧/CVRP 容量型 MTZ 约束.md"}'),e={name:"docs/02 技术/运筹优化/模型建模/建模技巧/CVRP 容量型 MTZ 约束.md"},n=$('<p>在 TSP 问题中，我们通常使用 MTZ 消除不包含起点的子路径 [[子路径消除 MTZ 约束]]</p><p>在 CVRP 中，MTZ 的变量 $u_i$ 可以被赋予新的物理意义，即代表车辆在离开客户 $i$ 时的<strong>剩余容量</strong>或<strong>已运载的货物量</strong>，从而同时进行<strong>子路径消除</strong>和<strong>容量检查</strong>。</p><h4 id="容量型-mtz-约束-cvrp" tabindex="-1">容量型 MTZ 约束 (CVRP) <a class="header-anchor" href="#容量型-mtz-约束-cvrp" aria-label="Permalink to &quot;容量型 MTZ 约束 (CVRP)&quot;">​</a></h4>',3),r=t("p",null,[_("$$\\mathbf{u}_i - \\mathbf{u}"),t("em",{ij:""},"j + Q \\cdot x"),_("^k \\leq Q - q_j \\quad \\forall i, j \\in N \\setminus {0}, i \\neq j, \\forall k \\in K$$")],-1),a=$('<p>其中：</p><ul><li><p><strong>$u_i$ (连续变量)：</strong> 代表车辆在<strong>离开</strong>客户 $i$ 时的<strong>剩余载荷能力</strong>（Remaining Capacity）。</p></li><li><p><strong>$Q$：</strong> 车辆的最大载重容量。</p></li><li><p><strong>$q_j$：</strong> 客户 $j$ 的需求量。</p></li></ul><h4 id="🔍-讲解容量型-mtz-的原理" tabindex="-1">🔍 讲解容量型 MTZ 的原理 <a class="header-anchor" href="#🔍-讲解容量型-mtz-的原理" aria-label="Permalink to &quot;🔍 讲解容量型 MTZ 的原理&quot;">​</a></h4><p>这个约束同时实现了序列强制和容量检查：</p><ol><li><p>如果 $x_{ij}^k=1$ (车辆 $k$ 访问 $j$ 紧随 $i$ 之后)：</p><p>约束变为：$u_i - u_j + Q \\leq Q - q_j$，即 $\\mathbf{u}_j \\geq \\mathbf{u}_i + q_j$。</p><ul><li><p><strong>容量检查：</strong> $u_i$ 是离开 $i$ 时的剩余载荷。要能运输货物到 $j$ 并满足 $j$ 的需求 $q_j$，则离开 $j$ 时的剩余载荷 $u_j$ 必须等于 $u_i$ 加上 $j$ 的需求 $q_j$。这个约束<strong>确保了车辆在访问 $j$ 时有足够的载荷空间</strong>（$u_i \\leq Q$ 且 $u_j \\leq Q$）。</p></li><li><p><strong>子路径消除：</strong> 像经典 MTZ 一样，它强制了 $u_j &gt; u_i$ 的顺序，从而避免了不包含仓库 $0$ 的子路径。</p></li></ul></li><li><p>$u_i$ 的边界约束：</p><p>通常还需要附加约束来定义 $u_i$ 的边界：</p><ul><li><p>$q_{\\min} \\leq u_i \\leq Q - q_{\\min}$</p></li><li><p>在仓库 $0$ 处，车辆出发时 $u_0 = Q$ (满载能力)，返回时 $u_0&#39; = 0$ (空载)。</p></li></ul></li></ol><p>因此，容量型 MTZ 约束将<strong>子路径消除</strong>和<strong>容量流平衡</strong>巧妙地结合在了一起。</p>',6),l=[n,r,a];function p(u,c,g,d,T,m){return s(),i("div",null,l)}const q=o(e,[["render",p]]);export{h as __pageData,q as default};
